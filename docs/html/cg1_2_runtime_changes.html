<HTML>

<HEAD>
<TITLE>cg1_2_runtime_changes</TITLE>
<meta name="description" content="cg1_2_runtime_changes" />
<meta name="keywords" content="cg1_2_runtime_changes, NVIDIA, NVIDIA Cg Toolkit, Cg Toolkit, Shader, Shader Programming, GPU Shader Programming, GPU Program" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<STYLE TYPE="text/css" MEDIA=screen>
<!--
		
BODY {
 font-family: Arial,Helvetica;
}

BLOCKQUOTE { margin: 10pt;  }

H1,A { color: #336699; }


/*** Top menu style ****/
.mmenuon { 
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #ff6600; font-size: 10pt;
 }
.mmenuoff { 
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #ffffff; font-size: 10pt;
}	  
.cpyright {
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #ffffff; font-size: xx-small;
}
.cpyrightText {
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #ffffff; font-size: xx-small;
}
.sections { 
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #336699; font-size: 11pt;
}	 
.dsections { 
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #336699; font-size: 12pt;
}	
.slink { 
 font-family: Arial,Helvetica; font-weight: normal; text-decoration: none;
 color: #336699; font-size: 9pt;
}	 

.slink2 { font-family: Arial,Helvetica; text-decoration: none; color: #336699; }	 

.maintitle { 
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #336699; font-size: 18pt;
}	 
.dblArrow {
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #336699; font-size: small;
}
.menuSec {
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #336699; font-size: small;
}

.newstext {
 font-family: Arial,Helvetica; font-size: small;
}

.linkmenu {
 font-family: Arial,Helvetica; color: #000000; font-weight: bold;
 text-decoration: none;
}

P {
 font-family: Arial,Helvetica;
}

PRE            { 
																font-family: monospace;
																white-space: pre; 
																font-color: #333333; 
																font-weight: 100;
																background-color: #eeeeee; 
																padding: 5px; 
																width: 90%; 
																border-style: solid;
																border-width: 2px; 
																border-color: #bebebe; 
	              }
.quote { 
 font-family: Times; text-decoration: none;
 color: #000000; font-size: 9pt; font-style: italic;
}	
.smstd { font-family: Arial,Helvetica; color: #000000; font-size: x-small; } 
.std { font-family: Arial,Helvetica; color: #000000; } 
.meerkatTitle { 
 font-family: sans-serif; font-size: x-small;  color: black;    }

.meerkatDescription { font-family: sans-serif; font-size: 10pt; color: black }
.meerkatCategory { 
 font-family: sans-serif; font-size: 9pt; font-weight: bold; font-style: italic; 
 color: brown; }
.meerkatChannel { 
 font-family: sans-serif; font-size: 9pt; font-style: italic; color: brown; }
.meerkatDate { font-family: sans-serif; font-size: xx-small; color: #336699; }

.tocTitle {
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #333333; font-size: 10pt;
}

.toc-item {
 font-family: Arial,Helvetica; font-weight: bold; 
 color: #336699; font-size: 10pt; text-decoration: underline;
}

.perlVersion {
 font-family: Arial,Helvetica; font-weight: bold; 
 color: #336699; font-size: 10pt; text-decoration: none;
}

.docTitle {
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #000000; font-size: 10pt;
}
.dotDot {
 font-family: Arial,Helvetica; font-weight: bold; 
 color: #000000; font-size: 9pt;
}

.docSec {
 font-family: Arial,Helvetica; font-weight: normal; 
 color: #333333; font-size: 9pt;
}
.docVersion {
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #336699; font-size: 10pt;
}

.docSecs-on {
 font-family: Arial,Helvetica; font-weight: normal; text-decoration: none;
 color: #ff0000; font-size: 10pt;
}
.docSecs-off {
 font-family: Arial,Helvetica; font-weight: normal; text-decoration: none;
 color: #333333; font-size: 10pt;
}

h3 {
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #336699; font-size: small;
}
h2 {
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #336699; font-size: medium;
}
h1 {
 font-family: Verdana,Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #336699; font-size: large;
}

DL {
 font-family: Arial,Helvetica; font-weight: normal; text-decoration: none;
 color: #333333; font-size: 10pt;
}

UL > LI > A {
 font-family: Arial,Helvetica; font-weight: bold;
 color: #336699; font-size: 10pt;
}

.moduleInfo {
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #333333; font-size: 11pt;
}

.moduleInfoSec {
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none;
 color: #336699; font-size: 10pt;
}

.moduleInfoVal {
 font-family: Arial,Helvetica; font-weight: normal; text-decoration: underline;
 color: #000000; font-size: 10pt;
}

.cpanNavTitle {
 font-family: Arial,Helvetica; font-weight: bold; 
 color: #ffffff; font-size: 10pt;
}
.cpanNavLetter {
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none; 
 color: #333333; font-size: 9pt;
}
.cpanCat {
 font-family: Arial,Helvetica; font-weight: bold; text-decoration: none; 
 color: #336699; font-size: 9pt;
}

-->
</STYLE>

</HEAD>

<BODY>

<object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
</object>

<BLOCKQUOTE>
<h2><a id="Cg_1.2_Runtime_API_Additions"></a>Cg 1.2 Runtime Api Additions</h2>
<p>
Version 1.2 of the Cg runtime adds a number of new capabilities to the
existing set of functionality from previous releases.  These new features
include functionality that make it possible to write programs that can run
more efficiently on the GPU, techniques that help hide some of the inherent
limitations of some Cg profiles on the GPU, and entrypoints that support
new language functionality in the Cg 1.2 release.
</p>
<h2><a id="Parameter_Literalization"></a>Parameter Literalization</h2>
<p>
The 1.2 Cg runtime makes it possible to denote some of the parameters to a
program as having a fixed constant value.  This feature can lead to
substantially more efficient programs in a number of cases.  For example,
a program might have a block of code that implements functionality that is
only used some of the time:
</p>
<pre>
float4 main(uniform float enableDazzle, ...) : COLOR {
  if (enableDazzle) {
    // do lengthy computation
  }
  else {
    // do basic computation
  }
}
</pre>
<p>
Some hardware profiles don't directly support branching (this includes all
of the fragment program profiles supported in this release), and have to
handle code like the program by effectively following both sides of the
if() test.  (They still compute the correct result in the end, just not
very efficiently.)
</p>
<p>
However, if the "enableDazzle" parameter is marked as a literal parameter
and a value is provided for it, the compiler can generate an optimized
version of the program with the knowledge of "enableDazzle"'s value, just
generating GPU code for one of the two cases.  This can lead to substantial
performance improvments.  This feature also makes it easier to write
general purpose shaders with a wide variety of supported functionality,
while only paying the runtime cost for the functionality provided.
</p>
<p>
This feature is also useful for parameters with numeric values.  For
example, consider a shader that implements a diffuse reflection model:
</p>
<pre>
float4 main(uniform float3 lightPos, uniform float3 lightColor,
            uniform float3 Kd, float3 pos : TEXCOORD0,
            float3 normal : TEXCOORD1) : COLOR
{
    return Kd*lightColor*max(0., dot(normalize(lightPos-pos), normal));
}
</pre>
<p>
If the "lightColor" and "Kd" parameters are set to literals, it is possible
for the compiler to compute the product "Kd * lightColor" once, rather than
once each time the program executes.
</p>
<p>
Given a parameter handle, the cgSetParameterVariability() entrypoint sets
the variability of a parameter:
</p>
<pre>    void cgSetParameterVariability(CGparameter param, CGenum vary);</pre>
<p>
To set it to a literal parameter, the CG_LITERAL enumerant should be passed
as the second parameter.
</p>
<p>
After a parameter has set to be a literal, the following routines should be
used to set the parameter's value.
</p>
<pre>
void cgSetParameter1f(CGparameter param, float x);
void cgSetParameter2f(CGparameter param, float x, float y);
void cgSetParameter3f(CGparameter param, float x, float y, float z);
void cgSetParameter4f(CGparameter param, float x, float y, float z,
                      float w);
void cgSetParameter1d(CGparameter param, double x);
void cgSetParameter2d(CGparameter param, double x, double y);
void cgSetParameter3d(CGparameter param, double x, double y, double z);
void cgSetParameter4d(CGparameter param, double x, double y, double z,
                      double w);

void cgSetParameter1fv(CGparameter param, const float *v);
void cgSetParameter2fv(CGparameter param, const float *v);
void cgSetParameter3fv(CGparameter param, const float *v);
void cgSetParameter4fv(CGparameter param, const float *v);
void cgSetParameter1dv(CGparameter param, const double *v);
void cgSetParameter2dv(CGparameter param, const double *v);
void cgSetParameter3dv(CGparameter param, const double *v);
void cgSetParameter4dv(CGparameter param, const double *v);

void cgSetMatrixParameterdr(CGparameter param, const double *matrix);
void cgSetMatrixParameterfr(CGparameter param, const float *matrix);
void cgSetMatrixParameterdc(CGparameter param, const double *matrix);
void cgSetMatrixParameterfc(CGparameter param, const float *matrix);
</pre>
<p>
After a parameter has been set to be a literal, or after the value of a
literal parameter has been changed, the program must be compiled and loaded
into the GPU, regardless of whether it had already been compiled.  This
issue is discussed further in the section on program recompilation below.
</p>
<h2><a id="Array_Size_Specification"></a>Array Size Specification</h2>
<p>
The Cg 1.2 language also adds support for ``unsized array'' variables;
programs can be written to take parameters that are arrays with an
indeterminate size.  The actual size of these arrays is then set via the Cg
runtime.  This feature is useful for writing general-purpose shaders
with a minimal performance penalty.
</p>
<p>
For example, consider a shader that computes shading given some number of
light sources.  If the information about each light source is stored in a
struct LightInfo, the shader might be written as:
</p>
<pre>
float4 main(LightInfo lights[], ...) : COLOR
{
   float4 color = float4(0,0,0,1);
   for (i = 0; i &lt; lights.length; ++i) {
      // add lights[i]'s contribution to color
   }
   return color;
}
</pre>
<p>
The runtime can then be used to set the length of the lights[] array (and
then to initialize the values of the LightInfo structures.)  As with
literal parameters, the program must be recompiled and reloaded after a
parameter's array size is set or changes.
</p>
<p>
These two entrypoints set the size of an unsized array parameter referenced
by the given parameter handle.  To set the size of a multidimensional
unsized array, all of the dimensions' sizes must be set simultaneously, by
providing them all via the pointer to an array of integer values.
</p>
<pre>
void cgSetArraySize(CGparameter param, int size);
void cgSetMultiDimArraySize(CGparameter param, const int *sizes);
</pre>
<p>XXX what happens if these are called with an already-sized array?? XXX</p>
<p>
To get the size of an array parameter, the cgGetArraySize() entrypoint can
be used.
</p>
<pre>    int cgGetArraySize(CGparameter param, int dimension);</pre>
<h2><a id="Program_Recompilation_at_Runtime"></a>Program Recompilation At Runtime</h2>
<p>
The Cg 1.2 runtime environment will allow automatic and manual recompilation
of programs.  This functionality is useful for multiple reasons :
</p>
<dl>
<dt><b>Changing variability of parameters</b></dt>
<dd>
Parameters may be changed from uniform variability to literal variability
as described above.
</dd>
<dt><b>Changing value of literal parameters</b></dt>
<dd>
Changing the value of a literal parameter will require recompilation since
the value is used at compile time.
</dd>
<dt><b>Resizing parameter arrays</b></dt>
<dd>
Changing the length of a parameter array may require recompilation depending
on the capabilities of the profile of the program.
</dd>
<dt><b>Binding sub-shader parameters</b></dt>
<dd>
Sub-shader parameters are structures that overload methods that need to be
provided at compile time; they are described below.  Binding such
parameters to program parameters will require recompilation.
</dd>
</dl>
<p>
Recompilation can be executed manually by the application using the runtime
or automatically by the runtime.
</p>
<p>The entry point:</p>
<pre>    void cgCompileProgram(CGprogram program);</pre>
<p>causes the given program to be recompiled, and the function:</p>
<pre>    CGbool cgIsProgramCompiled(CGprogram program);</pre>
<p>
reurns a boolean value indicating whether the current program needs
recompilation.
</p>
<p>
By default, programs are automatically compiled when cgCreateProgram() or
cgCreateProgramFromFile() is called.  This behavior can be controled with the
entry point :
</p>
<pre>    void cgSetAutoCompile(CGcontext ctx, CGenum flag);</pre>
<p>Where flag is one of the following three enumerants :</p>
<dl>
<dt><b>CG_COMPILE_MANUAL</b></dt>
<dd>
With this method the application is responsible for manually recompiling
a program.  It may check to see if a program requires recompilation with
the entry point <a href="cgIsProgramCompiled.html">cgIsProgramCompiled()</a>.
<a href="cgCompileProgram.html">cgCompileProgram()</a> can then
be used to force compilation.
</dd>
<dt><b>CG_COMPILE_IMMEDIATE</b></dt>
<dd>
<b>CG_COMPILE_IMMEDIATE</b> will force recompilation automatically and
immediately when a program enters an uncompiled state.
</dd>
<dt><b>CG_COMPILE_LAZY</b></dt>
<dd>
This method is similar to <b>CG_COMPILE_IMMEDIATE</b> but will delay
program recompilation until the program object code is needed.  The
advantage of this method is the reduction of extraneous recompilations.
The disadvantage is that compile time errors will not be encountered
when the program is enters the uncompiled state but will instead be
encountered at some later time.
</dd>
</dl>
<p>
For programs that use features like unsized arrays that can not be compiled until
their array sizes are set, it is good practice to change the default behavior
of compilation to CG_COMPILE_MANUAL so that cgCreateProgram() or
cgCreateProgramFromFile() do not unnecessarily encounter and report
compilation errors.
</p>
<h2><a id="Shared_Parameters__context_global_parameters_"></a>Shared Parameters (Context Global Parameters)</h2>
<p>
Version 1.2 of the runtime introduces parameters that may be shared across
programs in the same context via a new binding mechanism.  Once shared
parameters are constructed and bound to program parameters, setting the
value of the shared parameter will automatically set the value of all of
the program parameters they are bound to.
</p>
<p>

Shared parameters belong to a <b>CGcontext</b> instead of a <b>CGprogram</b>.
They may be created with the following new entry points :
</p>
<pre>
CGparameter cgCreateParameter(CGcontext ctx, CGtype type);
CGparameter cgCreateParameterArray(CGcontext ctx, CGtype type,
                                   int length);
CGparameter cgCreateParameterMultiDimArray(CGcontext ctx, CGtype type,
                                           int dim, const int *lengths);
</pre>
<p>They may be deleted with :</p>
<pre>    void cgDestroyParameter(CGparameter param);</pre>
<p>
After a parameter has been created, its value should be set with the
cgSetParameter*() routines described in the literalization section above.
</p>
<p>

Once a shared parameter is created it may be associated with any number of program
parameters with the call:
</p>
<pre>    void cgConnectParameter(CGparameter from, CGparameter to);</pre>
<p>
where ``from'' is a parameter created with one of  the cgCreateParameter()
calls, and ``to'' is a program parameter.
</p>
<p>
Given a program parameter, the handle to the shared parameter that is bound
to it (if any) can be found with the call:
</p>
<pre>    CGparameter cgGetConnectedParameter(CGparameter param);</pre>
<p>It returns NULL if no shared parameter has been connected to ``param''.</p>
<p>
There are also calls that make it possible to find the set of program
parameters to which a given shared parameter has been connected to.  The
entry point:
</p>
<pre>    int cgGetNumConnectedToParameters(CGparameter param);</pre>
<p>
returns the total number of program parameters that ``param'' has been
conencted to, and the entry point:
</p>
<pre>    CGparameter cgGetConnectedToParameter(CGparameter param, int index);</pre>
<p>
can be used to get CGparameter handles for each of the program parameters
to which a shared parameter is connected.
</p>
<p>A shared parameter can be unbound from a program parameter with :</p>
<pre>    void cgDisconnectParameter(CGparameter param);</pre>
<p>The context in which a shared parameter was created can be returned with:</p>
<pre>    CGcontext cgGetParameterContext(CGparameter param);</pre>
<p>And the entrypoint:</p>
<pre>    CGbool cgIsParameterGlobal(CGparameter param);</pre>
<p>can be used to determine if a parameter is a shared (global) parameter.</p>
<h2><a id="Shader_Interface_Support"></a>Shader Interface Support</h2>
<p>
From the runtime's perspective, shader interfaces are simply struct parameters that have
a <b>CGtype</b> associated with them.  For example, if the following Cg code is included
in some program source compiled in the runtime :
</p>
<pre>
interface FooInterface
{
  float SomeMethod(float x);
}

struct FooStruct : FooInterface
{
  float SomeMethod(float x);
  {
    return(Scale * x);
  }

  float Scale;
};
</pre>
<p>
The named types <b>FooInterface</b> and <b>FooStruct</b> will be added to the context.
Each one will have a unique <b>CGtype</b> associated with it.  The <b>CGtype</b> can
be retrieved with :
</p>
<pre>
CGtype cgGetNamedUserType(CGprogram program, const char *name);
int cgGetNumUserTypes(CGprogram program);
CGtype cgGetUserType(CGprogram program, int index);

CGbool cgIsParentType(CGtype parent, CGtype child);
CGbool cgIsInterfaceType(CGtype type);
</pre>
<p>
Once the <b>CGtype</b> has been retrieved, it may be used to construct an instance
of the struct using <a href="cgCreateParameter.html">cgCreateParameter</a>.  It may then
be connected to a program parameter of the parent type (in the above example this
would be FooInterface) using <a href="cgConnectParameter.html">cgConnectParameter</a>.
</p>
<p>
Calling <a href="cgGetParameterType.html">cgGetParameterType</a> on such a parameter will
return the <b>CG_STRUCT</b> to keep backwards compatibility with code that recurses
parameter trees.  In order to obtain the enumerant of the named type the
following entry point should be used :
</p>
<pre>    CGtype cgGetParameterNamedType(CGparameter param);</pre>
<p>
The parent types of a given named type may be obtained with the following
entry points :
</p>
<pre>
int cgGetNumParentTypes(CGtype type);
CGtype cgGetParentType(CGtype type, int index);
</pre>
<p>
If Cg source modules with differing definitions of named types are added to the
same context, an error will be thrown.
</p>
<p>XXX update for new scoping/context/program local definitions stuff XXX</p>
<h2><a id="Updated_Parameter_Management_Routines"></a>Updated Parameter Management Routines</h2>
<p>XXX where should these go?</p>
<p>Some entrypoints from before have been updated in backwards compatible ways</p>
<pre>
CGparameter cgGetFirstParameter(CGprogram program, CGenum name_space);
CGparameter cgGetFirstLeafParameter(CGprogram program, CGenum name_space);
</pre>
<p>
like cgGetNamedParameter, but limits search to the given name_space
(CG_PROGRAM or CG_GLOBAL)...
</p>
<pre>
CGparameter cgGetNamedProgramParameter(CGprogram program, CGenum name_space,
                                       const char *name);
</pre>
</BLOCKQUOTE>
</BODY>
